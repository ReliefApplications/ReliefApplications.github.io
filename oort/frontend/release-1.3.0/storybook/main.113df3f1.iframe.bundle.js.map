{"version":3,"file":"main.113df3f1.iframe.bundle.js","mappings":";;;;;;;;;;AAcA;;;;;;;;;;;;;;AAgBA;;;;;;;;;;AC3BA;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;ACvBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC8BA;;;;;;;;;;;;;;AAiBA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzLA;;;;;;;;;;;;;;;;;;;;ACaA;;;;;;;;;;;;;;;AAkBA;;;;;;;;AC/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;;;;;;;ACOA;;;;;;;;;;;;;;;;;ACFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgBA;;;;;;;;;;;;;;;;;;;;;;ACCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;;;;;;;;;ACdA;;;;;;;;;;;;;;;ACSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;;;;;;;;;;;;;;;;ACeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACcA;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;;;;;;;;;;;;;;;;;;;ACqBA;;;;;;;;;;;;;;;;;;;;;;;;ACPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;;;;;;;;;;;ACgCA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/MA;;;;;;;;;;;;;AAgBA;;;;;;AASA;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;AAmBA;;;;;;;AAUA;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;;AASA;;;;;;;AAUA;;;;;;;;;;;;;;;AAkBA;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0DA;;;;;;;;AAWA;;;;;;;;;AAWA;;;;;;;;;;;;;AAeA;;;;;;;;;AAWA;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;AAgBA;;;;;;;;AC5cA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACUA;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;;;;;;;;;;;ACIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmOA;;;;;;;;;;;AAWA;;;;;;;AAeA;;AAKA;AACA;;;AAIA;;AAoBA;;;;AAKA;;AAsDA;;;;AAKA","sources":["webpack://oort-front/./projects/safe/src/lib/services/aggregation/graphql/mutations.ts","webpack://oort-front/./projects/safe/src/lib/services/aggregation/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/services/aggregation/aggregation.service.ts","webpack://oort-front/./projects/safe/src/lib/components/widgets/grid/graphql/mutations.ts","webpack://oort-front/./projects/safe/src/lib/components/widgets/grid/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/services/workflow/graphql/mutations.ts","webpack://oort-front/./projects/safe/src/lib/services/grid-layout/graphql/mutations.ts","webpack://oort-front/./projects/safe/src/lib/services/grid-layout/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/services/grid-layout/grid-layout.service.ts","webpack://oort-front/./projects/safe/src/lib/components/resource-dropdown/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/components/resource-dropdown/resource-dropdown.component.ts","webpack://oort-front/./projects/safe/src/lib/components/application-dropdown/application-dropdown.component.ts","webpack://oort-front/./projects/safe/src/lib/components/record-dropdown/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/components/record-dropdown/record-dropdown.component.ts","webpack://oort-front/./projects/safe/src/lib/components/aggregation/aggregation-grid/aggregation-grid.component.ts","webpack://oort-front/./projects/safe/src/lib/components/widgets/scheduler/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/components/widgets/scheduler/scheduler.component.ts","webpack://oort-front/./projects/safe/src/lib/components/form-modal/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/components/form-modal/graphql/mutations.ts","webpack://oort-front/./projects/safe/src/lib/components/record-history/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/components/record-history/record-history.component.ts","webpack://oort-front/./projects/safe/src/lib/components/record-modal/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/components/ui/core-grid/graphql/mutations.ts","webpack://oort-front/./projects/safe/src/lib/components/ui/core-grid/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/components/convert-modal/convert-modal.component.ts","webpack://oort-front/./projects/safe/src/lib/components/widgets/grid-settings/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/services/application/graphql/mutations.ts","webpack://oort-front/./projects/safe/src/lib/services/application/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/services/application/graphql/subscriptions.ts","webpack://oort-front/./projects/safe/src/lib/components/reference-data-dropdown/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/services/form-builder/form-builder.service.ts","webpack://oort-front/./projects/safe/src/lib/services/query-builder/graphql/queries.ts","webpack://oort-front/./projects/safe/src/lib/services/query-builder/query-builder.service.ts"],"sourcesContent":["import { gql } from 'apollo-angular';\n/** Graphql request for adding a new aggregation with a given type */\nexport const ADD_AGGREGATION = gql `\n  mutation addAggregation($resource: ID, $aggregation: AggregationInputType!) {\n    addAggregation(resource: $resource, aggregation: $aggregation) {\n      id\n      name\n      sourceFields\n      pipeline\n      createdAt\n    }\n  }\n`;\n/** GraphQL request for editing a layout by its id */\nexport const EDIT_AGGREGATION = gql `\n  mutation editAggregation(\n    $resource: ID\n    $aggregation: AggregationInputType!\n    $id: ID!\n  ) {\n    editAggregation(resource: $resource, aggregation: $aggregation, id: $id) {\n      id\n      name\n      sourceFields\n      pipeline\n      createdAt\n    }\n  }\n`;\n/** Graphql request for deleting a aggregation by its id */\nexport const DELETE_AGGREGATION = gql `\n  mutation deleteAggregation($resource: ID, $id: ID!) {\n    deleteAggregation(resource: $resource, id: $id) {\n      id\n      name\n      sourceFields\n      pipeline\n      createdAt\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === GET RELATED FORMS FROM RESOURCE ===\n/** Graphql request to get resource aggregations */\nexport const GET_RESOURCE_AGGREGATIONS = gql `\n  query GetGridResourceMeta($resource: ID!, $ids: [ID], $first: Int) {\n    resource(id: $resource) {\n      id\n      name\n      queryName\n      aggregations(ids: $ids, first: $first) {\n        edges {\n          node {\n            id\n            name\n            sourceFields\n            pipeline\n            createdAt\n          }\n        }\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      }\n    }\n  }\n`;\n/** Query definition to get aggregation data */\nexport const GET_AGGREGATION_DATA = gql `\n  query GetAggregationData($resource: ID!, $aggregation: ID!, $mapping: JSON) {\n    recordsAggregation(\n      resource: $resource\n      aggregation: $aggregation\n      mapping: $mapping\n    )\n  }\n`;\n","import { __awaiter, __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { ADD_AGGREGATION, DELETE_AGGREGATION, EDIT_AGGREGATION, } from './graphql/mutations';\nimport { GET_AGGREGATION_DATA, GET_RESOURCE_AGGREGATIONS, } from './graphql/queries';\nimport { Apollo } from 'apollo-angular';\n/** Fallback AggregationConnection */\nconst FALLBACK_AGGREGATIONS = {\n    edges: [],\n    totalCount: 0,\n    pageInfo: {\n        startCursor: null,\n        endCursor: null,\n        hasNextPage: false,\n    },\n};\n/**\n * Shared service to manage aggregations.\n */\nlet SafeAggregationService = class SafeAggregationService {\n    /**\n     * Service for aggregations\n     *\n     * @param apollo The apollo service\n     */\n    constructor(apollo) {\n        this.apollo = apollo;\n    }\n    /**\n     * Gets list of aggregation from resourceId\n     *\n     * @param resourceId resourceId id\n     * @param options query options\n     * @param options.ids list of aggregation id\n     * @param options.first number of items to get\n     */\n    getAggregations(resourceId, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.apollo\n                .query({\n                query: GET_RESOURCE_AGGREGATIONS,\n                variables: {\n                    resource: resourceId,\n                    ids: options.ids,\n                    first: options.first,\n                },\n            })\n                .toPromise()\n                .then((res) => __awaiter(this, void 0, void 0, function* () {\n                if (res.errors) {\n                    return FALLBACK_AGGREGATIONS;\n                }\n                else {\n                    return res.data.resource.aggregations || FALLBACK_AGGREGATIONS;\n                }\n            }));\n        });\n    }\n    /**\n     * Builds the aggregation query from aggregation definition\n     *\n     * @param resource Resource Id\n     * @param aggregation Aggregation definition\n     * @param mapping aggregation mapping ( category, field, series )\n     * @returns Aggregation query\n     */\n    aggregationDataQuery(resource, aggregation, mapping) {\n        return this.apollo.query({\n            query: GET_AGGREGATION_DATA,\n            variables: {\n                resource,\n                aggregation,\n                mapping,\n            },\n        });\n    }\n    /**\n     * Edits a aggregation.\n     *\n     * @param aggregation aggregation to edit\n     * @param value new value of the aggregation\n     * @param resource resource the aggregation is attached to ( optional )\n     * @param form form the aggregation is attached to ( optional )\n     * @returns Mutation observable\n     */\n    editAggregation(aggregation, value, resource, form) {\n        return this.apollo.mutate({\n            mutation: EDIT_AGGREGATION,\n            variables: {\n                id: aggregation.id,\n                resource,\n                form,\n                aggregation: value,\n            },\n        });\n    }\n    /**\n     * Create a new aggregation\n     *\n     * @param value the value of the aggregation\n     * @param resource resource the aggregation is attached to ( optional )\n     * @param form form the aggregation is attached to ( optional )\n     * @returns Mutation observable\n     */\n    addAggregation(value, resource, form) {\n        return this.apollo.mutate({\n            mutation: ADD_AGGREGATION,\n            variables: {\n                resource,\n                form,\n                aggregation: value,\n            },\n        });\n    }\n    /**\n     * Delete an aggregation\n     *\n     * @param aggregation aggregation to edit\n     * @param resource resource the aggregation is attached to ( optional )\n     * @param form form the aggregation is attached to ( optional )\n     * @returns Mutation observable\n     */\n    deleteAggregation(aggregation, resource, form) {\n        return this.apollo.mutate({\n            mutation: DELETE_AGGREGATION,\n            variables: {\n                resource,\n                form,\n                id: aggregation.id,\n            },\n        });\n    }\n};\nSafeAggregationService.ctorParameters = () => [\n    { type: Apollo }\n];\nSafeAggregationService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SafeAggregationService);\nexport { SafeAggregationService };\n","import { gql } from 'apollo-angular';\n// === EDIT RECORD ===\n/** Graphql request for editing a record by its id */\nexport const EDIT_RECORD = gql `\n  mutation editRecord(\n    $id: ID!\n    $data: JSON\n    $version: ID\n    $template: ID\n    $display: Boolean\n    $lang: String\n  ) {\n    editRecord(\n      id: $id\n      data: $data\n      version: $version\n      template: $template\n      lang: $lang\n    ) {\n      id\n      incrementalId\n      data(display: $display)\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      validationErrors {\n        question\n        errors\n      }\n    }\n  }\n`;\n// === EDIT RECORDS ===\n/** Graphql request for editing multiple records by their ids */\nexport const EDIT_RECORDS = gql `\n  mutation editRecords(\n    $ids: [ID]!\n    $data: JSON!\n    $template: ID\n    $lang: String\n  ) {\n    editRecords(ids: $ids, data: $data, template: $template, lang: $lang) {\n      id\n      data\n      createdAt\n      modifiedAt\n    }\n  }\n`;\n// === PUBLISH RECORDS ===\n/** Graphql request for publishing rows to a channel */\nexport const PUBLISH = gql `\n  mutation publish($ids: [ID]!, $channel: ID!) {\n    publish(ids: $ids, channel: $channel)\n  }\n`;\n// === PUBLISH NOTIFICATION ===\n/** Graphql request for publishing a new notification onto a a channel */\nexport const PUBLISH_NOTIFICATION = gql `\n  mutation publishNotification(\n    $action: String!\n    $content: JSON!\n    $channel: ID!\n  ) {\n    publishNotification(action: $action, content: $content, channel: $channel) {\n      id\n      action\n      content\n      createdAt\n      channel {\n        id\n        title\n        application {\n          id\n          name\n        }\n      }\n      seenBy {\n        id\n        username\n      }\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === GET RECORD BY ID ===\n/** Graphql request for getting a record by its id */\nexport const GET_RECORD_BY_ID = gql `\n  query GetRecordById($id: ID!) {\n    record(id: $id) {\n      id\n      data\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      modifiedBy {\n        name\n      }\n      form {\n        id\n        structure\n        permissions {\n          recordsUnicity\n        }\n      }\n    }\n  }\n`;\n// === GET RECORD DETAILS ===\n/** Graphql request for getting record details by its id */\nexport const GET_RECORD_DETAILS = gql `\n  query GetRecordDetails($id: ID!) {\n    record(id: $id) {\n      id\n      data\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      form {\n        id\n        name\n        createdAt\n        structure\n        fields\n        core\n        resource {\n          id\n          name\n          forms {\n            id\n            name\n            structure\n            fields\n            core\n          }\n        }\n      }\n      versions {\n        id\n        createdAt\n        data\n        createdBy {\n          name\n        }\n      }\n    }\n  }\n`;\n// === GET QUERY TYPES ===\n/** Graphql request for getting query types */\nexport const GET_QUERY_TYPES = gql `\n  query GetQueryTypes {\n    __schema {\n      types {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            fields {\n              name\n              args {\n                name\n                type {\n                  name\n                  kind\n                  inputFields {\n                    name\n                    type {\n                      name\n                      kind\n                    }\n                  }\n                }\n              }\n              type {\n                name\n                kind\n                ofType {\n                  name\n                  fields {\n                    name\n                    type {\n                      name\n                      kind\n                      ofType {\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      queryType {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`;\n// === GET FORM ===\n/** Graphql query for getting a form by its id */\nexport const GET_FORM_BY_ID = gql `\n  query GetFormById($id: ID!) {\n    form(id: $id) {\n      id\n      name\n      fields\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === ADD STEP ===\n/** Graphql request for adding a new step of a given type to a workflow */\nexport const ADD_STEP = gql `\n  mutation addStep($type: String!, $content: ID, $workflow: ID!) {\n    addStep(type: $type, content: $content, workflow: $workflow) {\n      id\n      name\n      type\n      content\n      createdAt\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === ADD LAYOUT ===\n/** Graphql request for adding a new layout with a given type */\nexport const ADD_LAYOUT = gql `\n  mutation addLayout($resource: ID, $form: ID, $layout: LayoutInputType!) {\n    addLayout(resource: $resource, form: $form, layout: $layout) {\n      id\n      name\n      createdAt\n      query\n      display\n    }\n  }\n`;\n// === EDIT LAYOUT ===\n/** Grahql request for editing a layout by its id */\nexport const EDIT_LAYOUT = gql `\n  mutation editLayout(\n    $resource: ID\n    $form: ID\n    $layout: LayoutInputType!\n    $id: ID!\n  ) {\n    editLayout(resource: $resource, form: $form, layout: $layout, id: $id) {\n      id\n      name\n      createdAt\n      query\n      display\n    }\n  }\n`;\n// === DELETE LAYOUT ===\n/** Graphql request for deleting a layout by its id */\nexport const DELETE_LAYOUT = gql `\n  mutation deleteLayout($resource: ID, $form: ID, $id: ID!) {\n    deleteLayout(resource: $resource, form: $form, id: $id) {\n      id\n      name\n      createdAt\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === GET RELATED FORMS FROM RESOURCE ===\n/** Graphql request for getting resource meta date for a grid */\nexport const GET_GRID_RESOURCE_META = gql `\n  query GetGridResourceMeta(\n    $resource: ID!\n    $first: Int\n    $afterCursor: ID\n    $ids: [ID]\n  ) {\n    resource(id: $resource) {\n      id\n      name\n      queryName\n      forms {\n        id\n        name\n      }\n      relatedForms {\n        id\n        name\n        fields\n      }\n      layouts(first: $first, afterCursor: $afterCursor, ids: $ids) {\n        edges {\n          node {\n            id\n            name\n            query\n            createdAt\n            display\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n`;\n// === GET FORM BY ID ===\n/** Graphql request for getting the meta fields of a grid by form id */\nexport const GET_GRID_FORM_META = gql `\n  query GetFormAsTemplate($id: ID!, $first: Int, $afterCursor: ID) {\n    form(id: $id) {\n      id\n      name\n      queryName\n      layouts(first: $first, afterCursor: $afterCursor) {\n        edges {\n          node {\n            id\n            name\n            query\n            createdAt\n            display\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n`;\n","import { __awaiter, __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { Apollo } from 'apollo-angular';\nimport { ADD_LAYOUT, DELETE_LAYOUT, EDIT_LAYOUT, } from './graphql/mutations';\nimport { GET_GRID_RESOURCE_META, GET_GRID_FORM_META, } from './graphql/queries';\n/** Fallback LayoutConnection */\nconst FALLBACK_LAYOUTS = {\n    edges: [],\n    totalCount: 0,\n    pageInfo: {\n        startCursor: null,\n        endCursor: null,\n        hasNextPage: false,\n    },\n};\n/**\n * Shared service to manage grid predefined layouts.\n */\nlet SafeGridLayoutService = class SafeGridLayoutService {\n    /**\n     * Constructor the SafeGridLayoutService\n     *\n     * @param apollo The apollo service\n     */\n    constructor(apollo) {\n        this.apollo = apollo;\n    }\n    /**\n     * Gets list of layouts from source\n     *\n     *\n     * @param source source id\n     * @param options query options\n     * @param options.ids list of layout id\n     * @param options.first number of items to get\n     */\n    getLayouts(source, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.apollo\n                .query({\n                query: GET_GRID_RESOURCE_META,\n                variables: {\n                    resource: source,\n                    ids: options.ids,\n                    first: options.first,\n                },\n            })\n                .toPromise()\n                .then((res) => __awaiter(this, void 0, void 0, function* () {\n                if (res.errors) {\n                    return yield this.apollo\n                        .query({\n                        query: GET_GRID_FORM_META,\n                        variables: {\n                            id: source,\n                            ids: options.ids,\n                            first: options.first,\n                        },\n                    })\n                        .toPromise()\n                        .then((res2) => {\n                        if (res2.errors) {\n                            return FALLBACK_LAYOUTS;\n                        }\n                        else {\n                            return res2.data.form.layouts || FALLBACK_LAYOUTS;\n                        }\n                    });\n                }\n                else {\n                    return res.data.resource.layouts || FALLBACK_LAYOUTS;\n                }\n            }));\n        });\n    }\n    /**\n     * Edits a layout.\n     *\n     * @param layout layout to edit\n     * @param value new value of the layout\n     * @param resource resource the layout is attached to ( optional )\n     * @param form form the layout is attached to ( optional )\n     * @returns Mutation observable\n     */\n    editLayout(layout, value, resource, form) {\n        return this.apollo.mutate({\n            mutation: EDIT_LAYOUT,\n            variables: {\n                id: layout.id,\n                resource,\n                form,\n                layout: value,\n            },\n        });\n    }\n    /**\n     * Create a new layout\n     *\n     * @param value the value of the layout\n     * @param resource resource the layout is attached to ( optional )\n     * @param form form the layout is attached to ( optional )\n     * @returns Mutation observable\n     */\n    addLayout(value, resource, form) {\n        return this.apollo.mutate({\n            mutation: ADD_LAYOUT,\n            variables: {\n                resource,\n                form,\n                layout: value,\n            },\n        });\n    }\n    /**\n     * Delete a layout\n     *\n     * @param layout layout to edit\n     * @param resource resource the layout is attached to ( optional )\n     * @param form form the layout is attached to ( optional )\n     * @returns Mutation observable\n     */\n    deleteLayout(layout, resource, form) {\n        return this.apollo.mutate({\n            mutation: DELETE_LAYOUT,\n            variables: {\n                resource,\n                form,\n                id: layout.id,\n            },\n        });\n    }\n};\nSafeGridLayoutService.ctorParameters = () => [\n    { type: Apollo }\n];\nSafeGridLayoutService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SafeGridLayoutService);\nexport { SafeGridLayoutService };\n","import { gql } from 'apollo-angular';\n// === GET RESOURCE BY ID ===\n/** Graphql request for getting the name of a resource by its id */\nexport const GET_SHORT_RESOURCE_BY_ID = gql `\n  query GetShortResourceById($id: ID!) {\n    resource(id: $id) {\n      id\n      name\n    }\n  }\n`;\n// === GET RESOURCES ===\n/** Graphql request for getting resources */\nexport const GET_RESOURCES = gql `\n  query GetResources($first: Int, $afterCursor: ID, $sortField: String) {\n    resources(first: $first, afterCursor: $afterCursor, sortField: $sortField) {\n      edges {\n        node {\n          id\n          name\n        }\n        cursor\n      }\n      totalCount\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n    }\n  }\n`;\n","import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./resource-dropdown.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./resource-dropdown.component.scss?ngResource\";\nimport { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { Apollo } from 'apollo-angular';\nimport { GET_RESOURCES, GET_SHORT_RESOURCE_BY_ID, } from './graphql/queries';\n/** A constant that is used to determine how many items should be on one page. */\nconst ITEMS_PER_PAGE = 10;\n/**\n * This component is used to create a dropdown where the user can select a resource.\n */\nlet SafeResourceDropdownComponent = class SafeResourceDropdownComponent {\n    /**\n     * The constructor function is a special function that is called when a new instance of the class is\n     * created\n     *\n     * @param {Apollo} apollo - Apollo - This is the Apollo service that is used to create GraphQL queries.\n     */\n    constructor(apollo) {\n        this.apollo = apollo;\n        this.resource = '';\n        this.choice = new EventEmitter();\n    }\n    ngOnInit() {\n        if (this.resource) {\n            this.apollo\n                .query({\n                query: GET_SHORT_RESOURCE_BY_ID,\n                variables: {\n                    id: this.resource,\n                },\n            })\n                .subscribe((res) => {\n                if (res.data.resource) {\n                    this.selectedResource = res.data.resource;\n                }\n            });\n        }\n        this.resourcesQuery = this.apollo.watchQuery({\n            query: GET_RESOURCES,\n            variables: {\n                first: ITEMS_PER_PAGE,\n                sortField: 'name',\n            },\n        });\n    }\n    /**\n     * Emits the selected resource id.\n     *\n     * @param e select event.\n     */\n    onSelect(e) {\n        this.choice.emit(e);\n    }\n};\nSafeResourceDropdownComponent.ctorParameters = () => [\n    { type: Apollo }\n];\nSafeResourceDropdownComponent.propDecorators = {\n    resource: [{ type: Input }],\n    choice: [{ type: Output }]\n};\nSafeResourceDropdownComponent = __decorate([\n    Component({\n        selector: 'safe-resource-dropdown',\n        template: __NG_CLI_RESOURCE__0,\n        styles: [__NG_CLI_RESOURCE__1]\n    })\n], SafeResourceDropdownComponent);\nexport { SafeResourceDropdownComponent };\n","import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./application-dropdown.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./application-dropdown.component.scss?ngResource\";\nimport { Component, EventEmitter, Input, Output, ViewChild, } from '@angular/core';\nimport { Apollo } from 'apollo-angular';\nimport { BehaviorSubject } from 'rxjs';\nimport { MAT_SELECT_SCROLL_STRATEGY, } from '@angular/material/select';\nimport { GET_APPLICATIONS, } from './graphql/queries';\nimport { Overlay } from '@angular/cdk/overlay';\n/**\n * A constant that is used to set the number of items to be displayed on the page.\n */\nconst ITEMS_PER_PAGE = 10;\n/**\n * Scroll Factory for material select, provided by the component.\n *\n * @param overlay material overlay\n * @returns Strategy to prevent scrolling if user sees overlay.\n */\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function scrollFactory(overlay) {\n    const block = () => overlay.scrollStrategies.block();\n    return block;\n}\n/**\n * This is a component used to show a dropdown form where the user can choose an application\n */\nlet SafeApplicationDropdownComponent = class SafeApplicationDropdownComponent {\n    /**\n     * The constructor function is a special function that is called when a new instance of the class is\n     * created\n     *\n     * @param apollo This is the Apollo service that we'll use to make our GraphQL\n     * queries.\n     */\n    constructor(apollo) {\n        this.apollo = apollo;\n        this.value = [];\n        this.choice = new EventEmitter();\n        this.selectedApplications = [];\n        this.applications = new BehaviorSubject([]);\n        this.pageInfo = {\n            endCursor: '',\n            hasNextPage: true,\n        };\n        this.loading = true;\n    }\n    ngOnInit() {\n        if (Array.isArray(this.value) && this.value.length > 0) {\n            this.apollo\n                .query({\n                query: GET_APPLICATIONS,\n                variables: {\n                    filter: {\n                        logic: 'and',\n                        filters: [{ field: 'ids', operator: 'in', value: this.value }],\n                        // ids: this.value\n                    },\n                },\n            })\n                .subscribe((res) => {\n                this.selectedApplications = res.data.applications.edges.map((x) => x.node);\n            });\n        }\n        this.applicationsQuery =\n            this.apollo.watchQuery({\n                query: GET_APPLICATIONS,\n                variables: {\n                    first: ITEMS_PER_PAGE,\n                    sortField: 'name',\n                    sortOrder: 'asc',\n                },\n            });\n        this.applications$ = this.applications.asObservable();\n        this.applicationsQuery.valueChanges.subscribe((res) => {\n            this.applications.next(res.data.applications.edges.map((x) => x.node));\n            if (this.selectedApplications.length > 0) {\n                const applicationsIds = this.applications.getValue().map((x) => x.id);\n                this.selectedApplications = this.selectedApplications.filter((x) => applicationsIds.indexOf(x.id) < 0);\n            }\n            this.pageInfo = res.data.applications.pageInfo;\n            this.loading = res.loading;\n        });\n    }\n    /**\n     * Emits the selected resource id.\n     *\n     * @param e select event.\n     */\n    onSelect(e) {\n        this.choice.emit(e.value);\n    }\n    /**\n     * Adds scroll listener to select.\n     *\n     * @param e open select event.\n     */\n    onOpenSelect(e) {\n        if (e && this.applicationSelect) {\n            const panel = this.applicationSelect.panel.nativeElement;\n            panel.addEventListener('scroll', (event) => this.loadOnScroll(event));\n        }\n    }\n    /**\n     * Fetches more resources on scroll.\n     *\n     * @param e scroll event.\n     */\n    loadOnScroll(e) {\n        if (e.target.scrollHeight - (e.target.clientHeight + e.target.scrollTop) <\n            50) {\n            if (!this.loading && this.pageInfo.hasNextPage) {\n                this.loading = true;\n                this.applicationsQuery.fetchMore({\n                    variables: {\n                        first: ITEMS_PER_PAGE,\n                        afterCursor: this.pageInfo.endCursor,\n                    },\n                    updateQuery: (prev, { fetchMoreResult }) => {\n                        if (!fetchMoreResult) {\n                            return prev;\n                        }\n                        return Object.assign({}, prev, {\n                            applications: {\n                                edges: [\n                                    ...prev.applications.edges,\n                                    ...fetchMoreResult.applications.edges,\n                                ],\n                                pageInfo: fetchMoreResult.applications.pageInfo,\n                                totalCount: fetchMoreResult.applications.totalCount,\n                            },\n                        });\n                    },\n                });\n            }\n        }\n    }\n};\nSafeApplicationDropdownComponent.ctorParameters = () => [\n    { type: Apollo }\n];\nSafeApplicationDropdownComponent.propDecorators = {\n    value: [{ type: Input }],\n    choice: [{ type: Output }],\n    applicationSelect: [{ type: ViewChild, args: ['applicationSelect',] }]\n};\nSafeApplicationDropdownComponent = __decorate([\n    Component({\n        selector: 'safe-application-dropdown',\n        template: __NG_CLI_RESOURCE__0,\n        providers: [\n            {\n                provide: MAT_SELECT_SCROLL_STRATEGY,\n                useFactory: scrollFactory,\n                deps: [Overlay],\n            },\n        ],\n        styles: [__NG_CLI_RESOURCE__1]\n    })\n], SafeApplicationDropdownComponent);\nexport { SafeApplicationDropdownComponent };\n","import { gql } from 'apollo-angular';\n// === GET RECORD BY ID ===\n/** Graphql request for getting a record by its id */\nexport const GET_RECORD_BY_ID = gql `\n  query GetRecordById($id: ID!) {\n    record(id: $id) {\n      id\n      data\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      modifiedBy {\n        name\n      }\n      form {\n        id\n        structure\n        permissions {\n          recordsUnicity\n        }\n      }\n    }\n  }\n`;\n// === GET RECORDS FROM RESOURCE ===\n/** graphql request for getting records of a resource by its id */\nexport const GET_RESOURCE_RECORDS = gql `\n  query GetResourceRecords(\n    $id: ID!\n    $afterCursor: ID\n    $first: Int\n    $filter: JSON\n    $display: Boolean\n  ) {\n    resource(id: $id) {\n      records(first: $first, afterCursor: $afterCursor, filter: $filter) {\n        edges {\n          node {\n            id\n            data(display: $display)\n            versions {\n              id\n              createdAt\n              data\n            }\n            form {\n              id\n              name\n            }\n          }\n          cursor\n        }\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      }\n    }\n  }\n`;\n","import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./record-dropdown.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./record-dropdown.component.scss?ngResource\";\nimport { Overlay } from '@angular/cdk/overlay';\nimport { Component, EventEmitter, Input, Output, ViewChild, } from '@angular/core';\nimport { MAT_SELECT_SCROLL_STRATEGY, } from '@angular/material/select';\nimport { Apollo } from 'apollo-angular';\nimport { GET_RECORD_BY_ID, GET_RESOURCE_RECORDS, } from './graphql/queries';\nimport { BehaviorSubject } from 'rxjs';\nimport { TranslateService } from '@ngx-translate/core';\n/** A constant that is used to set the number of items to be displayed on the page. */\nconst ITEMS_PER_PAGE = 25;\n/**\n * Scroll Factory for material select, provided by the component.\n *\n * @param overlay material overlay\n * @returns Strategy to prevent scrolling if user sees overlay.\n */\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function scrollFactory(overlay) {\n    const block = () => overlay.scrollStrategies.block();\n    return block;\n}\n/**\n * A component to display a dropdown to select a record\n */\nlet SafeRecordDropdownComponent = class SafeRecordDropdownComponent {\n    /**\n     * The constructor function is a special function that is called when a new instance of the class is\n     * created.\n     *\n     * @param apollo This is the Apollo service use to generate GraphQL queries\n     * @param translate This is the service that we will use to translate the text in the platform\n     */\n    constructor(apollo, translate) {\n        this.apollo = apollo;\n        this.translate = translate;\n        this.record = '';\n        this.resourceId = '';\n        this.field = '';\n        this.placeholder = this.translate.instant('components.record.dropdown.select');\n        this.filter = {};\n        this.choice = new EventEmitter();\n        this.selectedRecord = null;\n        this.records = new BehaviorSubject([]);\n        this.pageInfo = {\n            endCursor: '',\n            hasNextPage: true,\n        };\n        this.loading = true;\n    }\n    ngOnInit() {\n        if (this.record) {\n            this.apollo\n                .query({\n                query: GET_RECORD_BY_ID,\n                variables: {\n                    id: this.record,\n                },\n            })\n                .subscribe((res) => {\n                if (res.data.record) {\n                    this.selectedRecord = res.data.record;\n                }\n            });\n        }\n        if (this.resourceId) {\n            this.recordsQuery =\n                this.apollo.watchQuery({\n                    query: GET_RESOURCE_RECORDS,\n                    variables: {\n                        id: this.resourceId,\n                        first: ITEMS_PER_PAGE,\n                        filter: this.filter,\n                    },\n                });\n            this.records$ = this.records.asObservable();\n            this.recordsQuery.valueChanges.subscribe((res) => {\n                this.records.next(res.data.resource.records.edges.map((x) => x.node));\n                this.pageInfo = res.data.resource.records.pageInfo;\n                this.loading = res.loading;\n            });\n        }\n    }\n    /**\n     * Emits the selected resource id.\n     *\n     * @param e select event.\n     */\n    onSelect(e) {\n        this.choice.emit(e.value);\n    }\n    /**\n     * Adds scroll listener to select.\n     *\n     * @param e open select event.\n     */\n    onOpenSelect(e) {\n        if (e && this.recordSelect) {\n            const panel = this.recordSelect.panel.nativeElement;\n            panel.addEventListener('scroll', (event) => this.loadOnScroll(event));\n        }\n    }\n    /**\n     * Fetches more items on scroll.\n     *\n     * @param e scroll event.\n     */\n    loadOnScroll(e) {\n        if (e.target.scrollHeight - (e.target.clientHeight + e.target.scrollTop) <\n            50) {\n            if (!this.loading && this.pageInfo.hasNextPage && this.resourceId) {\n                this.loading = true;\n                this.recordsQuery.fetchMore({\n                    variables: {\n                        id: this.resourceId,\n                        first: ITEMS_PER_PAGE,\n                        afterCursor: this.pageInfo.endCursor,\n                        filter: this.filter,\n                    },\n                    updateQuery: (prev, { fetchMoreResult }) => {\n                        if (!fetchMoreResult) {\n                            return prev;\n                        }\n                        if (this.selectedRecord) {\n                            if (fetchMoreResult.resource.records.edges.find((x) => { var _a; return x.node.id === ((_a = this.selectedRecord) === null || _a === void 0 ? void 0 : _a.id); })) {\n                                this.selectedRecord = null;\n                            }\n                        }\n                        return Object.assign({}, prev, {\n                            resource: {\n                                records: {\n                                    edges: [\n                                        ...prev.resource.records.edges,\n                                        ...fetchMoreResult.resource.records.edges,\n                                    ],\n                                    pageInfo: fetchMoreResult.resource.records.pageInfo,\n                                },\n                            },\n                        });\n                    },\n                });\n            }\n        }\n    }\n};\nSafeRecordDropdownComponent.ctorParameters = () => [\n    { type: Apollo },\n    { type: TranslateService }\n];\nSafeRecordDropdownComponent.propDecorators = {\n    record: [{ type: Input }],\n    resourceId: [{ type: Input }],\n    field: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    filter: [{ type: Input }],\n    choice: [{ type: Output }],\n    recordSelect: [{ type: ViewChild, args: ['recordSelect',] }]\n};\nSafeRecordDropdownComponent = __decorate([\n    Component({\n        selector: 'safe-record-dropdown',\n        template: __NG_CLI_RESOURCE__0,\n        providers: [\n            {\n                provide: MAT_SELECT_SCROLL_STRATEGY,\n                useFactory: scrollFactory,\n                deps: [Overlay],\n            },\n        ],\n        styles: [__NG_CLI_RESOURCE__1]\n    })\n], SafeRecordDropdownComponent);\nexport { SafeRecordDropdownComponent };\n","import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./aggregation-grid.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./aggregation-grid.component.scss?ngResource\";\nimport { Component, Input } from '@angular/core';\nimport { Apollo } from 'apollo-angular';\nimport { AggregationBuilderService } from '../../../services/aggregation-builder/aggregation-builder.service';\nimport { SafeAggregationService } from '../../../services/aggregation/aggregation.service';\nimport { PAGER_SETTINGS } from './aggregation-grid.constants';\nimport { GET_RESOURCE } from './graphql/queries';\n/**\n * Shared aggregation grid component.\n */\nlet SafeAggregationGridComponent = class SafeAggregationGridComponent {\n    /**\n     * Shared aggregation grid component\n     *\n     * @param aggregationService Shared aggregation service\n     * @param aggregationBuilderService Shared aggregation builder service\n     * @param apollo Apollo service\n     */\n    constructor(aggregationService, aggregationBuilderService, apollo) {\n        this.aggregationService = aggregationService;\n        this.aggregationBuilderService = aggregationBuilderService;\n        this.apollo = apollo;\n        this.gridData = [];\n        this.fields = [];\n        this.loading = false;\n        this.pageSize = 10;\n        this.pagerSettings = PAGER_SETTINGS;\n        this.showFilter = false;\n    }\n    /** @returns The column menu */\n    get columnMenu() {\n        return {\n            columnChooser: false,\n            filter: !this.showFilter,\n        };\n    }\n    ngOnInit() {\n        this.getAggregationData();\n        this.getAggregationFields();\n    }\n    ngOnChanges() {\n        this.getAggregationData();\n        this.getAggregationFields();\n    }\n    /**\n     * Get aggregation data from aggregation id and resource id\n     */\n    getAggregationData() {\n        this.loading = true;\n        this.gridData = [];\n        this.aggregationService\n            .aggregationDataQuery(this.resourceId, this.aggregation.id)\n            .subscribe((res) => {\n            this.gridData = res.data.recordsAggregation;\n            this.loading = false;\n        });\n    }\n    /**\n     * Get list of aggregation fields\n     */\n    getAggregationFields() {\n        this.apollo\n            .query({\n            query: GET_RESOURCE,\n            variables: {\n                id: this.resourceId,\n            },\n        })\n            .subscribe((res) => {\n            var _a;\n            const resource = res.data.resource;\n            this.fields = this.aggregationBuilderService.fieldsAfter(((_a = resource.metadata) === null || _a === void 0 ? void 0 : _a.filter((x) => this.aggregation.sourceFields.includes(x.name))) || [], this.aggregation.pipeline);\n        });\n    }\n    /**\n     * Toggles quick filter visibility\n     */\n    onToggleFilter() {\n        if (!this.loading) {\n            this.showFilter = !this.showFilter;\n            // this.onFilterChange({\n            //   logic: 'and',\n            //   filters: this.showFilter ? [] : this.filter.filters,\n            // });\n        }\n    }\n};\nSafeAggregationGridComponent.ctorParameters = () => [\n    { type: SafeAggregationService },\n    { type: AggregationBuilderService },\n    { type: Apollo }\n];\nSafeAggregationGridComponent.propDecorators = {\n    resourceId: [{ type: Input }],\n    aggregation: [{ type: Input }]\n};\nSafeAggregationGridComponent = __decorate([\n    Component({\n        selector: 'safe-aggregation-grid',\n        template: __NG_CLI_RESOURCE__0,\n        styles: [__NG_CLI_RESOURCE__1]\n    })\n], SafeAggregationGridComponent);\nexport { SafeAggregationGridComponent };\n","import { gql } from 'apollo-angular';\n// === GET FORM BY ID ===\n/** Graphql request for getting form data by its id */\nexport const GET_FORM_BY_ID = gql `\n  query GetFormById($id: ID!) {\n    form(id: $id) {\n      id\n      name\n      createdAt\n      structure\n      status\n      fields\n      resource {\n        id\n      }\n      canUpdate\n    }\n  }\n`;\n// === GET RESOURCE BY ID ===\n/** Graphql request for getting data of a resource by its id */\nexport const GET_RESOURCE_BY_ID = gql `\n  query GetResourceById($id: ID!, $filter: JSON, $display: Boolean) {\n    resource(id: $id) {\n      id\n      name\n      createdAt\n      records(filter: $filter) {\n        edges {\n          node {\n            id\n            data(display: $display)\n          }\n          cursor\n        }\n        totalCount\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      }\n      fields\n      forms {\n        id\n        name\n        status\n        createdAt\n        recordsCount\n        core\n        canUpdate\n        canDelete\n      }\n      coreForm {\n        uniqueRecord {\n          id\n        }\n      }\n      permissions {\n        canSee {\n          id\n          title\n        }\n        canUpdate {\n          id\n          title\n        }\n        canDelete {\n          id\n          title\n        }\n      }\n      canUpdate\n    }\n  }\n`;\n","import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./scheduler.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./scheduler.component.scss?ngResource\";\nimport { Apollo } from 'apollo-angular';\nimport { Component, Input } from '@angular/core';\nimport { GET_RESOURCE_BY_ID, GET_FORM_BY_ID, } from './graphql/queries';\n/** Component for scheduler widget */\nlet SafeSchedulerComponent = class SafeSchedulerComponent {\n    /**\n     * Constructor of the class\n     *\n     * @param apollo Apollo client\n     */\n    constructor(apollo) {\n        this.apollo = apollo;\n        // === SCHEDULER ===\n        this.currentYear = new Date().getFullYear();\n        this.selectedDate = new Date();\n        this.endlessDate = new Date(2100, 1, 1);\n        // === DATA ===\n        this.events = [];\n        this.loading = true;\n        // === WIDGET CONFIGURATION ===\n        this.header = true;\n        this.settings = null;\n    }\n    /** Load the data. */\n    ngOnInit() {\n        if (this.settings.source) {\n            this.getRecords();\n        }\n        else {\n            this.loading = false;\n        }\n    }\n    /** Load the data, using widget parameters. */\n    getRecords() {\n        if (!this.settings.from || this.settings.from === 'resource') {\n            this.apollo\n                .watchQuery({\n                query: GET_RESOURCE_BY_ID,\n                variables: {\n                    id: this.settings.source,\n                    display: true,\n                },\n            })\n                .valueChanges.subscribe((res) => {\n                var _a, _b, _c;\n                this.loading = false;\n                this.events =\n                    ((_c = (_b = (_a = res.data.resource) === null || _a === void 0 ? void 0 : _a.records) === null || _b === void 0 ? void 0 : _b.edges) === null || _c === void 0 ? void 0 : _c.map((item) => {\n                        var _a, _b, _c, _d, _e, _f, _g;\n                        return ({\n                            id: (_a = item.node) === null || _a === void 0 ? void 0 : _a.id,\n                            title: (_b = item.node) === null || _b === void 0 ? void 0 : _b.data[this.settings.events.title],\n                            description: this.settings.events.description\n                                ? (_c = item.node) === null || _c === void 0 ? void 0 : _c.data[this.settings.events.description]\n                                : null,\n                            start: ((_d = item.node) === null || _d === void 0 ? void 0 : _d.data[this.settings.events.startDate])\n                                ? this.parseAdjust((_e = item.node) === null || _e === void 0 ? void 0 : _e.data[this.settings.events.startDate])\n                                : new Date(),\n                            end: this.settings.events.endDate &&\n                                ((_f = item.node) === null || _f === void 0 ? void 0 : _f.data[this.settings.events.endDate])\n                                ? this.parseAdjust((_g = item.node) === null || _g === void 0 ? void 0 : _g.data[this.settings.events.endDate])\n                                : this.endlessDate,\n                        });\n                    })) || [];\n            });\n        }\n        else {\n            this.apollo\n                .watchQuery({\n                query: GET_FORM_BY_ID,\n                variables: {\n                    id: this.settings.source,\n                    display: true,\n                },\n            })\n                .valueChanges.subscribe((res) => {\n                var _a, _b;\n                this.loading = false;\n                this.events =\n                    ((_b = (_a = res.data.form) === null || _a === void 0 ? void 0 : _a.records) === null || _b === void 0 ? void 0 : _b.map((item) => ({\n                        id: item.id,\n                        title: item.data[this.settings.events.title],\n                        description: this.settings.events.description\n                            ? item.data[this.settings.events.description]\n                            : null,\n                        start: item.data[this.settings.events.startDate]\n                            ? this.parseAdjust(item.data[this.settings.events.startDate])\n                            : new Date(),\n                        end: this.settings.events.endDate &&\n                            item.data[this.settings.events.endDate]\n                            ? this.parseAdjust(item.data[this.settings.events.endDate])\n                            : this.endlessDate,\n                    }))) || [];\n            });\n        }\n    }\n    /**\n     * Correction applied to data, to have correct format.\n     *\n     * @param eventDate A date as a string\n     * @returns The same date transpose to the current year as Date object\n     */\n    parseAdjust(eventDate) {\n        const date = new Date(eventDate);\n        date.setFullYear(this.currentYear);\n        return date;\n    }\n};\nSafeSchedulerComponent.ctorParameters = () => [\n    { type: Apollo }\n];\nSafeSchedulerComponent.propDecorators = {\n    header: [{ type: Input }],\n    settings: [{ type: Input }]\n};\nSafeSchedulerComponent = __decorate([\n    Component({\n        selector: 'safe-scheduler',\n        template: __NG_CLI_RESOURCE__0,\n        styles: [__NG_CLI_RESOURCE__1]\n    })\n    /** Scheduler widget using KendoUI. */\n], SafeSchedulerComponent);\nexport { SafeSchedulerComponent };\n","import { gql } from 'apollo-angular';\n// === GET FORM BY ID ===\n/** Graphql request for getting form data by its id */\nexport const GET_FORM_BY_ID = gql `\n  query GetFormById($id: ID!) {\n    form(id: $id) {\n      id\n      name\n      createdAt\n      structure\n      status\n      fields\n      resource {\n        id\n      }\n      metadata\n      canUpdate\n    }\n  }\n`;\n// === GET RECORD BY ID ===\n/** Graphql request for getting a record by its id */\nexport const GET_RECORD_BY_ID = gql `\n  query GetRecordById($id: ID!) {\n    record(id: $id) {\n      id\n      data\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      modifiedBy {\n        name\n      }\n      form {\n        id\n        structure\n        permissions {\n          recordsUnicity\n        }\n        metadata\n      }\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === EDIT RECORD ===\n/** Graphql request for editing a record by its id */\nexport const EDIT_RECORD = gql `\n  mutation editRecord(\n    $id: ID!\n    $data: JSON\n    $version: ID\n    $template: ID\n    $display: Boolean\n    $lang: String\n  ) {\n    editRecord(\n      id: $id\n      data: $data\n      version: $version\n      template: $template\n      lang: $lang\n    ) {\n      id\n      incrementalId\n      data(display: $display)\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      validationErrors {\n        question\n        errors\n      }\n    }\n  }\n`;\n// === ADD RECORD ===\n/** Graphql request for adding a new record to a form */\nexport const ADD_RECORD = gql `\n  mutation addRecord($form: ID!, $data: JSON!, $display: Boolean) {\n    addRecord(form: $form, data: $data) {\n      id\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      data(display: $display)\n      form {\n        uniqueRecord {\n          id\n          modifiedAt\n          createdBy {\n            name\n          }\n          data\n        }\n      }\n    }\n  }\n`;\n// === UPLOAD FILE ===\n/** Graphql request for uploading a file to a form */\nexport const UPLOAD_FILE = gql `\n  mutation uploadFile($file: Upload!, $form: ID!) {\n    uploadFile(file: $file, form: $form)\n  }\n`;\n// === EDIT RECORDS ===\n/** Graphql request for editing multiple records by their ids */\nexport const EDIT_RECORDS = gql `\n  mutation editRecords(\n    $ids: [ID]!\n    $data: JSON!\n    $template: ID\n    $lang: String\n  ) {\n    editRecords(ids: $ids, data: $data, template: $template, lang: $lang) {\n      id\n      data\n      createdAt\n      modifiedAt\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n/** GraphQL query definition for getting record details for history purpose */\nexport const GET_RECORD_BY_ID_FOR_HISTORY = gql `\n  query GetRecordByIdForHistory($id: ID!) {\n    record(id: $id) {\n      id\n      incrementalId\n      form {\n        id\n        fields\n        structure\n      }\n    }\n  }\n`;\n/** GraphQL query definition to get record history by id */\nexport const GET_RECORD_HISTORY_BY_ID = gql `\n  query GetRecordHistoryByID($id: ID!, $lang: String) {\n    recordHistory(id: $id, lang: $lang) {\n      createdAt\n      createdBy\n      changes {\n        type\n        field\n        displayName\n        old\n        new\n      }\n      version {\n        id\n        createdAt\n        data\n      }\n    }\n  }\n`;\n","import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./record-history.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./record-history.component.scss?ngResource\";\nimport { Component, Input, EventEmitter, Output, ViewChild, } from '@angular/core';\nimport { MatEndDate, MatStartDate } from '@angular/material/datepicker';\nimport { MatDialog } from '@angular/material/dialog';\nimport { SafeRecordModalComponent } from '../record-modal/record-modal.component';\nimport { SafeDownloadService } from '../../services/download/download.service';\nimport { TranslateService } from '@ngx-translate/core';\nimport { SafeDateTranslateService } from '../../services/date-translate/date-translate.service';\nimport { Apollo } from 'apollo-angular';\nimport { SafeSnackBarService } from '../../services/snackbar/snackbar.service';\nimport { GET_RECORD_BY_ID_FOR_HISTORY, GET_RECORD_HISTORY_BY_ID, } from './graphql/queries';\n/**\n * Return the type of the old value if existing, else the type of the new value.\n *\n * @param oldVal The previous value\n * @param newVal The next value\n * @returns The type of the value: primitive, object or array\n */\nconst getValueType = (oldVal, newVal) => {\n    if (oldVal) {\n        if (Array.isArray(oldVal))\n            return 'array';\n        if (oldVal instanceof Object)\n            return 'object';\n        return 'primitive';\n    }\n    if (Array.isArray(newVal))\n        return 'array';\n    if (newVal instanceof Object)\n        return 'object';\n    return 'primitive';\n};\n/**\n * This is a component to access the history of a record\n */\nlet SafeRecordHistoryComponent = class SafeRecordHistoryComponent {\n    /**\n     * Constructor of the record history component\n     *\n     * @param dialog The material dialog service\n     * @param downloadService The download service\n     * @param translate The translation service\n     * @param dateFormat The dateTranslation service\n     * @param apollo The apollo client\n     * @param snackBar The snackbar service\n     */\n    constructor(dialog, downloadService, translate, dateFormat, apollo, snackBar) {\n        this.dialog = dialog;\n        this.downloadService = downloadService;\n        this.translate = translate;\n        this.dateFormat = dateFormat;\n        this.apollo = apollo;\n        this.snackBar = snackBar;\n        this.cancel = new EventEmitter();\n        this.history = [];\n        this.filterHistory = [];\n        this.loading = true;\n        this.showMore = false;\n        this.displayedColumns = ['position'];\n        this.filtersDate = { startDate: '', endDate: '' };\n        this.sortedFields = [];\n        this.filterField = null;\n    }\n    /** @returns filename from current date and record inc. id */\n    get fileName() {\n        const today = new Date();\n        const formatDate = `${today.toLocaleString('en-us', {\n            month: 'short',\n            day: 'numeric',\n        })} ${today.getFullYear()}`;\n        return `${this.record.incrementalId} ${formatDate}`;\n    }\n    ngOnInit() {\n        // this.sortFields();\n        this.apollo\n            .query({\n            query: GET_RECORD_BY_ID_FOR_HISTORY,\n            variables: {\n                id: this.id,\n            },\n        })\n            .subscribe((res) => {\n            this.record = res.data.record;\n            this.sortedFields = this.sortFields(this.getFields());\n        });\n        this.apollo\n            .query({\n            query: GET_RECORD_HISTORY_BY_ID,\n            variables: {\n                id: this.id,\n                lang: this.translate.currentLang,\n            },\n        })\n            .subscribe((res) => {\n            if (res.errors) {\n                this.snackBar.openSnackBar(this.translate.instant('common.notifications.history.error', {\n                    error: res.errors[0].message,\n                }), { error: true });\n                this.cancel.emit(true);\n            }\n            else {\n                this.history = res.data.recordHistory.filter((item) => item.changes.length);\n                this.filterHistory = this.history;\n                this.loading = false;\n            }\n        });\n    }\n    /**\n     * Handles the cancelling of the edition of the history\n     */\n    onCancel() {\n        this.cancel.emit(true);\n    }\n    /**\n     * Gets the HTML element from a change object\n     *\n     * @param change The field change object\n     * @returns the innerHTML for the listing\n     */\n    getHTMLFromChange(change) {\n        const translations = {\n            withValue: this.translate.instant('components.history.changes.withValue'),\n            from: this.translate.instant('components.history.changes.from'),\n            to: this.translate.instant('components.history.changes.to'),\n            add: this.translate.instant('components.history.changes.add'),\n            remove: this.translate.instant('components.history.changes.remove'),\n            modify: this.translate.instant('components.history.changes.modify'),\n        };\n        let oldVal = change.old ? JSON.parse(change.old) : undefined;\n        let newVal = change.new ? JSON.parse(change.new) : undefined;\n        const valueType = getValueType(oldVal, newVal);\n        if (valueType === 'object') {\n            if (oldVal)\n                oldVal = this.toReadableObjectValue(oldVal);\n            if (newVal)\n                newVal = this.toReadableObjectValue(newVal);\n        }\n        if (valueType === 'array') {\n            if (oldVal && !(oldVal[0] instanceof Object))\n                oldVal = oldVal.join(', ');\n            else if (oldVal)\n                oldVal = this.toReadableObjectValue(oldVal);\n            if (newVal && !(newVal[0] instanceof Object))\n                newVal = newVal.join(', ');\n            else if (newVal)\n                newVal = this.toReadableObjectValue(newVal);\n        }\n        switch (change.type) {\n            case 'remove':\n            case 'add':\n                return `\n          <p>\n            <span class=\"${change.type}-field\">\n            ${translations[change.type]}\n            </span>\n            <b> ${change.displayName} </b>\n            ${translations.withValue}\n            <b> ${change.type === 'add' ? newVal : oldVal}</b>\n          <p>\n          `;\n            case 'modify':\n                return `\n          <p>\n            <span class=\"${change.type}-field\">\n            ${translations[change.type]}\n            </span>\n            <b> ${change.displayName} </b>\n            ${translations.from}\n            <b> ${oldVal}</b>\n            ${translations.to}\n            <b> ${newVal}</b>\n          <p>\n          `;\n        }\n    }\n    /**\n     * Transforms a object in a more readable inline string (or list)\n     *\n     * @param object The object\n     * @returns A 'readable' version of that object, in which the the format key (value1, value2)\n     */\n    toReadableObjectValue(object) {\n        // base case\n        if (typeof object !== 'object')\n            return object;\n        // arrys\n        if (Array.isArray(object)) {\n            return object.map((elem) => this.toReadableObjectValue(elem));\n        }\n        // objects - non arrays\n        const res = [];\n        const keys = Object.keys(object);\n        keys.forEach((key, i) => {\n            res.push(`${i ? ' ' : ''}${key} (${this.toReadableObjectValue(object[key])})`);\n        });\n        return res;\n    }\n    /**\n     * Display a modal to show previous version, and revert to it if user accepts.\n     *\n     * @param version The version to revert\n     */\n    onRevert(version) {\n        var _a;\n        const dialogRef = this.dialog.open(SafeRecordModalComponent, {\n            data: {\n                recordId: this.id,\n                compareTo: (_a = this.history.find((item) => { var _a; return ((_a = item.version) === null || _a === void 0 ? void 0 : _a.id) === version.id; })) === null || _a === void 0 ? void 0 : _a.version,\n                template: this.template,\n            },\n            autoFocus: false,\n        });\n        dialogRef.afterClosed().subscribe((value) => {\n            if (value) {\n                this.revert(version);\n            }\n        });\n    }\n    /**\n     * Clears the date filter, empties it\n     */\n    clearDateFilter() {\n        this.filtersDate.startDate = '';\n        this.filtersDate.endDate = '';\n        this.filterHistory = this.history;\n        this.startDate.value = '';\n        this.endDate.value = '';\n    }\n    /**\n     * Triggers when the selected date and field filters are changed\n     * and filters the history accordingly\n     *\n     * @param filterField the name of the field being filtered, if any\n     */\n    applyFilter(filterField) {\n        // undefined => function called from date change\n        // null => 'All fields' selected\n        // other => Field name for filter\n        if (filterField !== undefined)\n            this.filterField = filterField || null;\n        const startDate = this.filtersDate.startDate\n            ? new Date(this.filtersDate.startDate)\n            : undefined;\n        if (startDate)\n            startDate.setHours(0, 0, 0, 0);\n        const endDate = this.filtersDate.endDate\n            ? new Date(this.filtersDate.endDate)\n            : undefined;\n        if (endDate)\n            endDate.setHours(23, 59, 59, 99);\n        // filtering by date\n        this.filterHistory = this.history.filter((item) => {\n            const createdAt = new Date(item.createdAt);\n            return (!startDate ||\n                !endDate ||\n                (createdAt >= startDate && createdAt <= endDate));\n        });\n        // filtering by field\n        if (this.filterField !== null) {\n            this.filterHistory = this.filterHistory\n                .filter((item) => !!item.changes.find((change) => this.filterField === change.field))\n                .map((item) => {\n                const newItem = Object.assign({}, item);\n                newItem.changes = item.changes.filter((change) => change.field === this.filterField);\n                return newItem;\n            });\n        }\n    }\n    /**\n     * Handle the download event. Send a request to the server to get excel / csv file.\n     *\n     * @param type Type of document to download\n     */\n    onDownload(type) {\n        const path = `download/form/records/${this.id}/history`;\n        const queryString = new URLSearchParams(Object.assign({ type, from: `${new Date(this.filtersDate.startDate).getTime()}`, to: `${new Date(this.filtersDate.endDate).getTime()}`, lng: this.translate.currentLang, dateLocale: this.dateFormat.currentLang }, (this.filterField && { field: this.filterField }))).toString();\n        this.downloadService.getFile(`${path}?${queryString}`, `text/${type};charset=utf-8;`, `${this.fileName}.${type}`);\n    }\n    /**\n     * Parses the structure of the record and sorts the fields\n     * based on their names or lables, if available\n     *\n     * @param fields Array of fields\n     * @returns sorted array of fields\n     */\n    sortFields(fields) {\n        const unsortedFields = [...fields];\n        return unsortedFields.sort((a, b) => {\n            const compA = a.title || a.name;\n            const compB = b.title || b.name;\n            return compA.toLowerCase() > compB.toLowerCase() ? 1 : -1;\n        });\n    }\n    /**\n     * Get fields from the form\n     *\n     * @returns Returns an array with all the fields.\n     */\n    getFields() {\n        var _a;\n        const fields = [];\n        // No form, break the display\n        if (this.record.form) {\n            // Take the fields from the form\n            (_a = this.record.form.fields) === null || _a === void 0 ? void 0 : _a.map((field) => {\n                fields.push(Object.assign({}, field));\n            });\n            if (this.record.form.structure) {\n                const structure = JSON.parse(this.record.form.structure);\n                if (!structure.pages || !structure.pages.length) {\n                    return [];\n                }\n                for (const page of structure.pages) {\n                    this.extractFields(page, fields);\n                }\n            }\n        }\n        return fields;\n    }\n    /**\n     * Extract fields from form structure in order to get titles.\n     *\n     * @param object Structure to inspect, can be a page, a panel.\n     * @param fields Array of fields.\n     */\n    extractFields(object, fields) {\n        if (object.elements) {\n            for (const element of object.elements) {\n                if (element.type === 'panel') {\n                    this.extractFields(element, fields);\n                }\n                else {\n                    const field = fields.find((x) => x.name === element.name);\n                    if (field && element.title) {\n                        if (typeof element.title === 'string') {\n                            field.title = element.title;\n                        }\n                        else {\n                            field.title = element.title.default;\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\nSafeRecordHistoryComponent.ctorParameters = () => [\n    { type: MatDialog },\n    { type: SafeDownloadService },\n    { type: TranslateService },\n    { type: SafeDateTranslateService },\n    { type: Apollo },\n    { type: SafeSnackBarService }\n];\nSafeRecordHistoryComponent.propDecorators = {\n    id: [{ type: Input }],\n    revert: [{ type: Input }],\n    template: [{ type: Input }],\n    cancel: [{ type: Output }],\n    startDate: [{ type: ViewChild, args: ['startDate', { read: MatStartDate },] }],\n    endDate: [{ type: ViewChild, args: ['endDate', { read: MatEndDate },] }]\n};\nSafeRecordHistoryComponent = __decorate([\n    Component({\n        selector: 'safe-record-history',\n        template: __NG_CLI_RESOURCE__0,\n        styles: [__NG_CLI_RESOURCE__1]\n    })\n], SafeRecordHistoryComponent);\nexport { SafeRecordHistoryComponent };\n","import { gql } from 'apollo-angular';\n// === GET RECORD BY ID ===\n/** Graphql request for getting a record by its id */\nexport const GET_RECORD_BY_ID = gql `\n  query GetRecordById($id: ID!) {\n    record(id: $id) {\n      id\n      data\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      modifiedBy {\n        name\n      }\n      form {\n        id\n        structure\n        permissions {\n          recordsUnicity\n        }\n        fields\n        metadata\n      }\n    }\n  }\n`;\n// === GET FORM BY ID ===\n/** Graphql request for getting the form structure by its id */\nexport const GET_FORM_STRUCTURE = gql `\n  query GetFormById($id: ID!) {\n    form(id: $id) {\n      id\n      structure\n      metadata\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === CONVERT RECORD ===\n/** Graphql request for converting a record with its id and its form id */\nexport const CONVERT_RECORD = gql `\n  mutation convertRecord($id: ID!, $form: ID!, $copyRecord: Boolean!) {\n    convertRecord(id: $id, form: $form, copyRecord: $copyRecord) {\n      id\n      createdAt\n      modifiedAt\n    }\n  }\n`;\n// === DELETE RECORD ===\n/** Graphl request for deleting multiple records by their ids */\nexport const DELETE_RECORDS = gql `\n  mutation deleteRecords($ids: [ID]!) {\n    deleteRecords(ids: $ids)\n  }\n`;\n// === EDIT RECORD ===\n/** Graphql request for editing a record by its id */\nexport const EDIT_RECORD = gql `\n  mutation editRecord(\n    $id: ID!\n    $data: JSON\n    $version: ID\n    $template: ID\n    $display: Boolean\n    $lang: String\n  ) {\n    editRecord(\n      id: $id\n      data: $data\n      version: $version\n      template: $template\n      lang: $lang\n    ) {\n      id\n      incrementalId\n      data(display: $display)\n      createdAt\n      modifiedAt\n      createdBy {\n        name\n      }\n      validationErrors {\n        question\n        errors\n      }\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === GET FORM BY ID ===\n/** Graphql request for getting form data by its id */\nexport const GET_FORM_BY_ID = gql `\n  query GetFormById($id: ID!) {\n    form(id: $id) {\n      id\n      name\n      createdAt\n      structure\n      status\n      fields\n      resource {\n        id\n      }\n      canUpdate\n    }\n  }\n`;\n// === GET QUERY TYPES ===\n/** Graphql request for getting query types */\nexport const GET_QUERY_TYPES = gql `\n  query GetQueryTypes {\n    __schema {\n      types {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            fields {\n              name\n              args {\n                name\n                type {\n                  name\n                  kind\n                  inputFields {\n                    name\n                    type {\n                      name\n                      kind\n                    }\n                  }\n                }\n              }\n              type {\n                name\n                kind\n                ofType {\n                  name\n                  fields {\n                    name\n                    type {\n                      name\n                      kind\n                      ofType {\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      queryType {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`;\n","import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./convert-modal.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./convert-modal.component.scss?ngResource\";\nimport { Apollo } from 'apollo-angular';\nimport { Component, Inject } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { GET_RECORD_DETAILS, } from './graphql/queries';\n/**\n * This component is used in the grids to display a modal after clicking on the \"convert\" button.\n * This modal allows the user to configurate the convertion.\n */\nlet SafeConvertModalComponent = class SafeConvertModalComponent {\n    /**\n     * The constructor function is a special function that is called when a new instance of the class is\n     * created.\n     *\n     * @param formBuilder This is used to create a form.\n     * @param apollo This is the Apollo service that we'll use to make the GraphQL mutation.\n     * @param dialogRef This is the reference of the dialog that will be opened\n     * @param data This is the data that is passed into the modal when it is opened.\n     */\n    constructor(formBuilder, apollo, dialogRef, data) {\n        this.formBuilder = formBuilder;\n        this.apollo = apollo;\n        this.dialogRef = dialogRef;\n        this.data = data;\n        // === REACTIVE FORM ===\n        this.convertForm = new FormGroup({});\n        this.availableForms = [];\n        this.ignoredFields = [];\n        // === LOAD DATA ===\n        this.loading = true;\n    }\n    ngOnInit() {\n        var _a;\n        this.apollo\n            .watchQuery({\n            query: GET_RECORD_DETAILS,\n            variables: {\n                id: this.data.record,\n            },\n        })\n            .valueChanges.subscribe((res) => {\n            var _a, _b, _c;\n            const record = res.data.record;\n            this.form = record.form;\n            this.loading = false;\n            this.availableForms =\n                ((_c = (_b = (_a = this.form) === null || _a === void 0 ? void 0 : _a.resource) === null || _b === void 0 ? void 0 : _b.forms) === null || _c === void 0 ? void 0 : _c.filter((x) => { var _a; return x.id !== ((_a = this.form) === null || _a === void 0 ? void 0 : _a.id); })) ||\n                    [];\n        });\n        this.convertForm = this.formBuilder.group({\n            targetForm: [null, Validators.required],\n            copyRecord: [true, Validators.required],\n        });\n        (_a = this.convertForm\n            .get('targetForm')) === null || _a === void 0 ? void 0 : _a.valueChanges.subscribe((targetForm) => {\n            var _a, _b;\n            if (targetForm) {\n                this.ignoredFields =\n                    ((_b = (_a = this.form) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.filter((sourceField) => {\n                        var _a;\n                        return !((_a = targetForm === null || targetForm === void 0 ? void 0 : targetForm.fields) === null || _a === void 0 ? void 0 : _a.some((targetField) => sourceField.name === targetField.name));\n                    })) || [];\n            }\n        });\n    }\n    /**\n     * Closes the modal without sending data.\n     */\n    onClose() {\n        this.dialogRef.close();\n    }\n};\nSafeConvertModalComponent.ctorParameters = () => [\n    { type: FormBuilder },\n    { type: Apollo },\n    { type: MatDialogRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }\n];\nSafeConvertModalComponent = __decorate([\n    Component({\n        selector: 'safe-convert-modal',\n        template: __NG_CLI_RESOURCE__0,\n        styles: [__NG_CLI_RESOURCE__1]\n    })\n], SafeConvertModalComponent);\nexport { SafeConvertModalComponent };\n","import { gql } from 'apollo-angular';\n// === GET CHANNELS ===\n/** Graphql request for getting channels (optionnally by an application id) */\nexport const GET_CHANNELS = gql `\n  query getChannels($application: ID) {\n    channels(application: $application) {\n      id\n      title\n      application {\n        id\n        name\n      }\n    }\n  }\n`;\n// === GET META FIELDS OF A GRID ===\n/** Graphql request for getting the meta fields of a grid by form id */\nexport const GET_GRID_FORM_META = gql `\n  query GetFormAsTemplate($id: ID!, $layoutIds: [ID], $first: Int) {\n    form(id: $id) {\n      id\n      name\n      queryName\n      layouts(ids: $layoutIds, first: $first) {\n        edges {\n          node {\n            id\n            name\n            createdAt\n            query\n            display\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n`;\n// === GET RELATED FORMS FROM RESOURCE ===\n/** Graphql request for getting resource meta date for a grid */\nexport const GET_GRID_RESOURCE_META = gql `\n  query GetGridResourceMeta(\n    $resource: ID!\n    $layoutIds: [ID]\n    $firstLayouts: Int\n    $aggregationIds: [ID]\n    $firstAggregations: Int\n  ) {\n    resource(id: $resource) {\n      id\n      name\n      queryName\n      forms {\n        id\n        name\n      }\n      relatedForms {\n        id\n        name\n        fields\n        resource {\n          id\n          queryName\n          name\n          fields\n        }\n      }\n      layouts(ids: $layoutIds, first: $firstLayouts) {\n        edges {\n          node {\n            id\n            name\n            query\n            createdAt\n            display\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        totalCount\n      }\n      aggregations(ids: $aggregationIds, first: $firstAggregations) {\n        edges {\n          node {\n            id\n            name\n            sourceFields\n            pipeline\n            createdAt\n          }\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        totalCount\n      }\n    }\n  }\n`;\n// === GET QUERY TYPES ===\n/** Graphql request for getting query types */\nexport const GET_QUERY_TYPES = gql `\n  query GetQueryTypes {\n    __schema {\n      types {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            fields {\n              name\n              args {\n                name\n                type {\n                  name\n                  kind\n                  inputFields {\n                    name\n                    type {\n                      name\n                      kind\n                    }\n                  }\n                }\n              }\n              type {\n                name\n                kind\n                ofType {\n                  name\n                  fields {\n                    name\n                    type {\n                      name\n                      kind\n                      ofType {\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      queryType {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`;\n// === GET RESOURCES ===\n/** Graphql query for getting multiple resources with a cursor */\nexport const GET_RESOURCES = gql `\n  query GetResources($first: Int, $afterCursor: ID, $sortField: String) {\n    resources(first: $first, afterCursor: $afterCursor, sortField: $sortField) {\n      edges {\n        node {\n          id\n          name\n          forms {\n            id\n            name\n          }\n        }\n        cursor\n      }\n      totalCount\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === ADD PAGE ===\n/** Graphql request for adding a new page of a given type to an application */\nexport const ADD_PAGE = gql `\n  mutation addPage($type: ContentEnumType!, $content: ID, $application: ID!) {\n    addPage(type: $type, content: $content, application: $application) {\n      id\n      name\n      type\n      content\n      createdAt\n      canSee\n      canUpdate\n      canDelete\n    }\n  }\n`;\n// === DUPLICATE PAGES ===\n/** Duplicate page mutation, used by Application service. */\nexport const DUPLICATE_PAGE = gql `\n  mutation duplicatePage($id: ID!, $application: ID!) {\n    duplicatePage(id: $id, application: $application) {\n      id\n      name\n      type\n      content\n      createdAt\n      canSee\n      canUpdate\n      canDelete\n    }\n  }\n`;\n// === DELETE PAGE ===\n/** Graphql request for deleting a page by its id */\nexport const DELETE_PAGE = gql `\n  mutation deletePage($id: ID!) {\n    deletePage(id: $id) {\n      id\n    }\n  }\n`;\n// === ADD ROLE ===\n/** Graphql request for adding a new role to an application */\nexport const ADD_ROLE = gql `\n  mutation addRole($title: String!, $application: ID) {\n    addRole(title: $title, application: $application) {\n      id\n      title\n      permissions {\n        id\n        type\n      }\n      usersCount\n    }\n  }\n`;\n// === EDIT ROLE ===\n/** Graphql request for editing a role by its id */\nexport const EDIT_ROLE = gql `\n  mutation editRole(\n    $id: ID!\n    $permissions: [ID]\n    $channels: [ID]\n    $title: String\n  ) {\n    editRole(\n      id: $id\n      permissions: $permissions\n      channels: $channels\n      title: $title\n    ) {\n      id\n      title\n      permissions {\n        id\n        type\n      }\n      usersCount\n      channels {\n        id\n        title\n        application {\n          id\n          name\n        }\n      }\n    }\n  }\n`;\n// === DELETE ROLE ===\n/** Graphql request for deleting a role by its id */\nexport const DELETE_ROLE = gql `\n  mutation deleteRole($id: ID!) {\n    deleteRole(id: $id) {\n      id\n    }\n  }\n`;\n/** Graphql request for adding a role to a user */\nexport const ADD_ROLE_TO_USERS = gql `\n  mutation addRoleToUsers(\n    $usernames: [String]!\n    $role: ID!\n    $positionAttributes: [PositionAttributeInputType]\n  ) {\n    addRoleToUsers(\n      usernames: $usernames\n      role: $role\n      positionAttributes: $positionAttributes\n    ) {\n      id\n      username\n      name\n      roles {\n        id\n        title\n      }\n      oid\n    }\n  }\n`;\n// === EDIT USER ===\n/** Graphql request for editing roles of a user by its id */\nexport const EDIT_USER = gql `\n  mutation editUser(\n    $id: ID!\n    $roles: [ID]!\n    $application: ID\n    $positionAttributes: [PositionAttributeInputType]\n  ) {\n    editUser(\n      id: $id\n      roles: $roles\n      application: $application\n      positionAttributes: $positionAttributes\n    ) {\n      id\n      username\n      name\n      roles {\n        id\n        title\n        application {\n          id\n        }\n      }\n      positionAttributes {\n        value\n        category {\n          id\n          title\n        }\n      }\n      oid\n    }\n  }\n`;\n// === DELETE USER FROM APPLICATION ===\n/** Graphql request for removing multiple users from an application  */\nexport const DELETE_USERS_FROM_APPLICATION = gql `\n  mutation deleteUsersFromApplication($ids: [ID]!, $application: ID!) {\n    deleteUsersFromApplication(ids: $ids, application: $application) {\n      id\n      username\n      name\n      roles {\n        id\n        title\n      }\n      oid\n    }\n  }\n`;\n// === ADD CHANNEL ===\n/** Graphql request for adding a new channel to an application */\nexport const ADD_CHANNEL = gql `\n  mutation addChannel($title: String!, $application: ID!) {\n    addChannel(title: $title, application: $application) {\n      id\n      title\n      application {\n        id\n        name\n      }\n      subscribedRoles {\n        id\n        title\n        usersCount\n      }\n    }\n  }\n`;\n// === EDIT CHANNEL ===\n/** Graphql request for editing a channel by its id */\nexport const EDIT_CHANNEL = gql `\n  mutation editChannel($id: ID!, $title: String!) {\n    editChannel(id: $id, title: $title) {\n      id\n      title\n    }\n  }\n`;\n// === DELETE CHANNEL ===\n/** Graphql request for deleting a channel */\nexport const DELETE_CHANNEL = gql `\n  mutation deleteChannel($id: ID!) {\n    deleteChannel(id: $id) {\n      id\n      title\n    }\n  }\n`;\n// === ADD SUBSCRIPTION ===\n/** Graphql request for adding a new subscription to an application */\nexport const ADD_SUBSCRIPTION = gql `\n  mutation addSubscription(\n    $application: ID!\n    $routingKey: String!\n    $title: String!\n    $convertTo: ID\n    $channel: ID\n  ) {\n    addSubscription(\n      application: $application\n      routingKey: $routingKey\n      title: $title\n      convertTo: $convertTo\n      channel: $channel\n    ) {\n      routingKey\n      title\n      convertTo {\n        id\n        name\n      }\n      channel {\n        id\n        title\n      }\n    }\n  }\n`;\n// === EDIT SUBSCRIPTION ===\n/** Graphql resuest for editing a subscription in an application */\nexport const EDIT_SUBSCRIPTION = gql `\n  mutation editSubscription(\n    $applicationId: ID!\n    $routingKey: String!\n    $title: String!\n    $convertTo: String!\n    $channel: String!\n    $previousSubscription: String!\n  ) {\n    editSubscription(\n      applicationId: $applicationId\n      routingKey: $routingKey\n      title: $title\n      convertTo: $convertTo\n      channel: $channel\n      previousSubscription: $previousSubscription\n    ) {\n      routingKey\n      title\n      convertTo {\n        id\n        name\n      }\n      channel {\n        id\n        title\n      }\n    }\n  }\n`;\n// === DELETE SUBSCRIPTION ===\n/** Grahql request for deleting a subscription from an application */\nexport const DELETE_SUBSCRIPTION = gql `\n  mutation deleteSubscription($applicationId: ID!, $routingKey: String!) {\n    deleteSubscription(applicationId: $applicationId, routingKey: $routingKey) {\n      id\n    }\n  }\n`;\n// === ADD POSITION ===\n/** Graphql request for adding a new position attribute category to an application */\nexport const ADD_POSITION_ATTRIBUTE_CATEGORY = gql `\n  mutation addPositionAttributeCategory($title: String!, $application: ID!) {\n    addPositionAttributeCategory(title: $title, application: $application) {\n      id\n      title\n    }\n  }\n`;\n// === EDIT POSITION ===\n/** Graphql request for editing position attribute category in an application */\nexport const EDIT_POSITION_ATTRIBUTE_CATEGORY = gql `\n  mutation editPositionAttributeCategory(\n    $id: ID!\n    $application: ID!\n    $title: String!\n  ) {\n    editPositionAttributeCategory(\n      id: $id\n      application: $application\n      title: $title\n    ) {\n      id\n      title\n    }\n  }\n`;\n// === DELETE POSITION ===\n/** Graphql request for deleting a position attribute category from an application */\nexport const DELETE_POSITION_ATTRIBUTE_CATEGORY = gql `\n  mutation deletePositionAttributeCategory($id: ID!, $application: ID!) {\n    deletePositionAttributeCategory(id: $id, application: $application) {\n      id\n    }\n  }\n`;\n// === EDIT APPLICATION ===\n/** Graphql request for editing an application by its id */\nexport const EDIT_APPLICATION = gql `\n  mutation editApplication(\n    $id: ID!\n    $name: String\n    $status: Status\n    $pages: [ID]\n    $permissions: JSON\n    $description: String\n  ) {\n    editApplication(\n      id: $id\n      name: $name\n      status: $status\n      pages: $pages\n      permissions: $permissions\n      description: $description\n    ) {\n      id\n      description\n      name\n      createdAt\n      modifiedAt\n      status\n      pages {\n        id\n        name\n        createdAt\n        type\n        content\n        canDelete\n        canSee\n        canUpdate\n      }\n      settings\n      permissions {\n        canSee {\n          id\n          title\n        }\n        canUpdate {\n          id\n          title\n        }\n        canDelete {\n          id\n          title\n        }\n      }\n      canSee\n      canUpdate\n      canDelete\n      locked\n      lockedByUser\n    }\n  }\n`;\n// === TOGGLE APPLICATION LOCK ===\n/** Graphql request for toggling the application lock state */\nexport const TOGGLE_APPLICATION_LOCK = gql `\n  mutation toggleApplicationLock($id: ID!, $lock: Boolean!) {\n    toggleApplicationLock(id: $id, lock: $lock) {\n      id\n      locked\n      lockedByUser\n    }\n  }\n`;\n// TEMPLATE OPERATIONS\n/** Graphql request for adding a template to an application */\nexport const ADD_TEMPLATE = gql `\n  mutation addTemplate($application: ID!, $template: TemplateInputType!) {\n    addTemplate(application: $application, template: $template) {\n      id\n      name\n      type\n      content\n    }\n  }\n`;\n/** Graphql request for editing a template of an application */\nexport const UPDATE_TEMPLATE = gql `\n  mutation editTemplate(\n    $application: ID!\n    $id: ID!\n    $template: TemplateInputType!\n  ) {\n    editTemplate(application: $application, id: $id, template: $template) {\n      id\n      name\n      type\n      content\n    }\n  }\n`;\n/** Graphql request for deleting a template of an application */\nexport const DELETE_TEMPLATE = gql `\n  mutation deleteTemplate($application: ID!, $id: ID!) {\n    deleteTemplate(application: $application, id: $id) {\n      id\n      name\n      type\n      content\n    }\n  }\n`;\n/** Graphql request for editing a distribution list of an application */\nexport const UPDATE_DISTRIBUTION_LIST = gql `\n  mutation editDistributionList(\n    $application: ID!\n    $id: ID!\n    $distributionList: DistributionListInputType!\n  ) {\n    editDistributionList(\n      application: $application\n      id: $id\n      distributionList: $distributionList\n    ) {\n      id\n      name\n      emails\n    }\n  }\n`;\n/** Graphql request for adding a template of an application */\nexport const ADD_DISTRIBUTION_LIST = gql `\n  mutation addDistributionList(\n    $application: ID!\n    $distributionList: DistributionListInputType!\n  ) {\n    addDistributionList(\n      application: $application\n      distributionList: $distributionList\n    ) {\n      id\n      name\n      emails\n    }\n  }\n`;\n/** Graphql request for adding a template of an application */\nexport const DELETE_DISTRIBUTION_LIST = gql `\n  mutation deleteDistributionList($application: ID!, $id: ID!) {\n    deleteDistributionList(application: $application, id: $id) {\n      id\n      name\n      emails\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === GET APPLICATION BY ID ===\n/** Graphql request for getting application data by its id */\nexport const GET_APPLICATION_BY_ID = gql `\n  query GetApplicationById($id: ID!, $asRole: ID) {\n    application(id: $id, asRole: $asRole) {\n      id\n      name\n      description\n      createdAt\n      status\n      templates {\n        id\n        name\n        type\n        content\n      }\n      distributionLists {\n        id\n        name\n        emails\n      }\n      pages {\n        id\n        name\n        type\n        content\n        createdAt\n        canSee\n        canUpdate\n        canDelete\n      }\n      roles {\n        id\n        title\n        permissions {\n          id\n          type\n        }\n        usersCount\n        channels {\n          id\n          title\n          application {\n            id\n            name\n          }\n        }\n        application {\n          id\n          name\n        }\n      }\n      users {\n        id\n        username\n        name\n        roles {\n          id\n          title\n        }\n        positionAttributes {\n          value\n          category {\n            id\n            title\n          }\n        }\n        oid\n      }\n      permissions {\n        canSee {\n          id\n          title\n        }\n        canUpdate {\n          id\n          title\n        }\n        canDelete {\n          id\n          title\n        }\n      }\n      channels {\n        id\n        title\n        subscribedRoles {\n          id\n          title\n          application {\n            id\n            name\n          }\n          usersCount\n        }\n      }\n      subscriptions {\n        routingKey\n        title\n        channel {\n          id\n          title\n        }\n        convertTo {\n          id\n          name\n        }\n      }\n      canSee\n      canUpdate\n      canDelete\n      positionAttributeCategories {\n        id\n        title\n      }\n      locked\n      lockedByUser\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n/** Graphql request  for listening to unlocking of applications */\nexport const APPLICATION_UNLOCKED_SUBSCRIPTION = gql `\n  subscription applicationUnlocked($id: ID!) {\n    applicationUnlocked(id: $id) {\n      id\n      locked\n      lockedByUser\n    }\n  }\n`;\n/** Graphql request for listening to editing of applications */\nexport const APPLICATION_EDITED_SUBSCRIPTION = gql `\n  subscription applicationEdited($id: ID!) {\n    applicationEdited(id: $id) {\n      id\n      name\n      description\n      createdAt\n      status\n      canSee\n      canUpdate\n      lockedBy {\n        id\n        name\n      }\n    }\n  }\n`;\n","import { gql } from 'apollo-angular';\n// === GET REFERENCE DATAS ===\n/** GraphQL query to get list of reference data */\nexport const GET_REFERENCE_DATAS = gql `\n  query GetReferenceDatas($first: Int, $afterCursor: ID) {\n    referenceDatas(first: $first, afterCursor: $afterCursor) {\n      edges {\n        node {\n          id\n          name\n        }\n        cursor\n      }\n      totalCount\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n    }\n  }\n`;\n/** Graphql query to get reference data */\nexport const GET_SHORT_REFERENCE_DATA_BY_ID = gql `\n  query GetShortReferenceDataById($id: ID!) {\n    referenceData(id: $id) {\n      id\n      name\n    }\n  }\n`;\n","import { __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { TranslateService } from '@ngx-translate/core';\nimport * as Survey from 'survey-angular';\nimport { SafeReferenceDataService } from '../reference-data/reference-data.service';\nimport { renderGlobalProperties } from '../../survey/render-global-properties';\nimport { Apollo } from 'apollo-angular';\nimport get from 'lodash/get';\nimport { EDIT_RECORD } from './graphql/mutations';\n/**\n * Shared form builder service.\n * Only used to add on complete expression to the survey.\n */\nlet SafeFormBuilderService = class SafeFormBuilderService {\n    /**\n     * Constructor of the service\n     *\n     * @param referenceDataService Reference data service\n     * @param translate Translation service\n     * @param apollo Apollo service\n     */\n    constructor(referenceDataService, translate, apollo) {\n        this.referenceDataService = referenceDataService;\n        this.translate = translate;\n        this.apollo = apollo;\n    }\n    /**\n     * Creates new survey from the structure and add on complete expression to it.\n     *\n     * @param structure form structure\n     * @param fields list of fields used to check if the fields should be hidden or disabled\n     * @param record record that'll be edited, if any\n     * @returns New survey\n     */\n    createSurvey(structure, fields = [], record) {\n        const survey = new Survey.Model(structure);\n        survey.onAfterRenderQuestion.add(renderGlobalProperties(this.referenceDataService));\n        survey.onCompleting.add(() => {\n            for (const page of survey.toJSON().pages) {\n                for (const element of page.elements) {\n                    if (element.type === 'resources' || element.type === 'resource') {\n                        // if its a single record, the value will be string\n                        // so we account for that by putting it in an array\n                        const valueIterator = (element.type === 'resources'\n                            ? survey.getValue(element.name)\n                            : [survey.getValue(element.name)]) || [];\n                        const regex = /{\\s*(\\b.*\\b)\\s*}\\s*=\\s*\"(.*)\"/g;\n                        for (const item of valueIterator) {\n                            let operation;\n                            if (element.newCreatedRecords &&\n                                element.newCreatedRecords.includes(item) &&\n                                element.afterRecordCreation) {\n                                regex.lastIndex = 0; // ensure that regex restarts\n                                operation = regex.exec(element.afterRecordCreation); // divide string into groups for key : value mapping\n                            }\n                            else if (element.afterRecordSelection) {\n                                regex.lastIndex = 0; // ensure that regex restarts\n                                const isNewlySelected = element.type === 'resources'\n                                    ? !get(record, `data.${element.name}`, []).includes(item)\n                                    : !(get(record, `data.${element.name}`, null) === item);\n                                // only updates those records that were not in the old value for the field\n                                if (isNewlySelected)\n                                    operation = regex.exec(element.afterRecordSelection); // divide string into groups for key : value mapping\n                            }\n                            this.updateRecord(item, operation);\n                        }\n                    }\n                }\n            }\n        });\n        if (fields.length > 0) {\n            for (const f of fields.filter((x) => !x.automated)) {\n                const accessible = !!f.canSee;\n                const editable = !!f.canUpdate;\n                const hidden = (f.canSee !== undefined && !f.canSee) || false;\n                const disabled = (f.canUpdate !== undefined && !f.canUpdate) || false;\n                const question = survey.getQuestionByName(f.name);\n                if (question) {\n                    question.visible = !hidden && accessible;\n                    question.readOnly = disabled || !editable;\n                }\n            }\n        }\n        // set the lang of the survey\n        const surveyLang = localStorage.getItem('surveyLang');\n        if (surveyLang && survey.getUsedLocales().includes(surveyLang)) {\n            survey.locale = surveyLang;\n        }\n        else {\n            const lang = this.translate.currentLang || this.translate.defaultLang;\n            if (survey.getUsedLocales().includes(lang)) {\n                survey.locale = lang;\n            }\n        }\n        return survey;\n    }\n    /**\n     * Updates the field with the specified information.\n     *\n     * @param id Id of the record to update\n     * @param operation Operation to execute\n     */\n    updateRecord(id, operation) {\n        if (id && operation) {\n            this.apollo\n                .mutate({\n                mutation: EDIT_RECORD,\n                variables: {\n                    id,\n                    data: { [operation[1]]: operation[2] },\n                },\n            })\n                .subscribe(() => { });\n        }\n    }\n};\nSafeFormBuilderService.ctorParameters = () => [\n    { type: SafeReferenceDataService },\n    { type: TranslateService },\n    { type: Apollo }\n];\nSafeFormBuilderService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], SafeFormBuilderService);\nexport { SafeFormBuilderService };\n","import { gql } from 'apollo-angular';\n/**\n * Get metadata of form / resource query definition.\n */\nexport const GET_QUERY_META_DATA = gql `\n  query GetQueryMetaData($id: ID!) {\n    form(id: $id) {\n      id\n      metadata\n    }\n    resource(id: $id) {\n      id\n      metadata\n    }\n  }\n`;\n/** Graphql request for getting query types */\nexport const GET_QUERY_TYPES = gql `\n  query GetQueryTypes {\n    __schema {\n      types {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            fields {\n              name\n              args {\n                name\n                type {\n                  name\n                  kind\n                  inputFields {\n                    name\n                    type {\n                      name\n                      kind\n                    }\n                  }\n                }\n              }\n              type {\n                name\n                kind\n                ofType {\n                  name\n                  fields {\n                    name\n                    type {\n                      name\n                      kind\n                      ofType {\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      queryType {\n        name\n        kind\n        fields {\n          name\n          args {\n            name\n            type {\n              name\n              kind\n              inputFields {\n                name\n                type {\n                  name\n                  kind\n                }\n              }\n            }\n          }\n          type {\n            name\n            kind\n            ofType {\n              name\n              fields {\n                name\n                type {\n                  name\n                  kind\n                  ofType {\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`;\n","import { __decorate } from \"tslib\";\nimport { Apollo, gql } from 'apollo-angular';\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { GET_QUERY_META_DATA, GET_QUERY_TYPES, } from './graphql/queries';\nimport { FormBuilder } from '@angular/forms';\nimport get from 'lodash/get';\n/** List of fields part of the schema but not selectable */\nconst NON_SELECTABLE_FIELDS = ['canUpdate', 'canDelete'];\n/** List of fields part of the schema but not selectable */\nconst SELECTABLE_ID_FIELDS = ['id', 'incrementalId', 'form'];\n/** List of user fields */\nconst USER_FIELDS = ['id', 'name', 'username'];\n/** ReferenceData identifier convention */\nexport const REFERENCE_DATA_END = 'Ref';\n/**\n * Shared query builder service. The query builder service is used by the widgets, that creates the query based on their settings.\n * Query builder service only performs query on the schema generated on the go from the forms / resources definitions.\n */\nlet QueryBuilderService = class QueryBuilderService {\n    /**\n     * Shared query builder service. The query builder service is used by the widgets, that creates the query based on their settings.\n     * Query builder service only performs query on the schema generated on the go from the forms / resources definitions.\n     *\n     * @param apollo Apollo client\n     * @param formBuilder Angular form builder\n     */\n    constructor(apollo, formBuilder) {\n        this.apollo = apollo;\n        this.formBuilder = formBuilder;\n        /** Available forms / resources queries */\n        this.availableQueries = new BehaviorSubject([]);\n        /** Available forms / resources types */\n        this.availableTypes = new BehaviorSubject([]);\n        /** User fields */\n        this.userFields = [];\n        this.apollo\n            .query({\n            query: GET_QUERY_TYPES,\n        })\n            .subscribe((res) => {\n            // eslint-disable-next-line no-underscore-dangle\n            this.availableTypes.next(res.data.__schema.types);\n            this.availableQueries.next(\n            // eslint-disable-next-line no-underscore-dangle\n            res.data.__schema.queryType.fields.filter((x) => x.name.startsWith('all')));\n            // eslint-disable-next-line no-underscore-dangle\n            this.userFields = res.data.__schema.types\n                .find((x) => x.name === 'User')\n                .fields.filter((x) => USER_FIELDS.includes(x.name));\n        });\n    }\n    /** @returns Available forms / resources queries as observalbe */\n    get availableQueries$() {\n        return this.availableQueries.asObservable();\n    }\n    /** @returns Available forms / resources types as observable */\n    get availableTypes$() {\n        return this.availableTypes.asObservable();\n    }\n    /**\n     * Gets list of fields from a type.\n     *\n     * @param type Corresponding type from availablTypes.\n     * @returns List of fields of this type.\n     */\n    extractFieldsFromType(type) {\n        return type.fields\n            .filter((x) => !NON_SELECTABLE_FIELDS.includes(x.name) &&\n            (SELECTABLE_ID_FIELDS.includes(x.name) || x.type.name !== 'ID') &&\n            (x.type.kind !== 'LIST' || x.type.ofType.name !== 'ID'))\n            .map((x) => {\n            if (x.type.kind === 'OBJECT') {\n                return Object.assign({}, x, {\n                    type: Object.assign({}, x.type, {\n                        fields: x.type.fields.filter((y) => y.type.kind === 'SCALAR' &&\n                            !NON_SELECTABLE_FIELDS.includes(y.name) &&\n                            (x.type.name !== 'User' || USER_FIELDS.includes(y.name))),\n                    }),\n                });\n            }\n            return x;\n        })\n            .sort((a, b) => a.name.localeCompare(b.name));\n    }\n    /**\n     * Gets list of fields from a query name.\n     *\n     * @param queryName Form / Resource query name.\n     * @returns List of fields of this structure.\n     */\n    getFields(queryName) {\n        var _a;\n        const query = this.availableQueries\n            .getValue()\n            .find((x) => x.name === queryName);\n        const typeName = ((_a = query === null || query === void 0 ? void 0 : query.type) === null || _a === void 0 ? void 0 : _a.name.replace('Connection', '')) || '';\n        const type = this.availableTypes\n            .getValue()\n            .find((x) => x.name === typeName);\n        return type ? this.extractFieldsFromType(type) : [];\n    }\n    /**\n     * Gets list of fields from a type.\n     *\n     * @param typeName Form / Resource type.\n     * @returns List of fields of this structure.\n     */\n    getFieldsFromType(typeName) {\n        if (typeName === 'User') {\n            return this.userFields;\n        }\n        const type = this.availableTypes\n            .getValue()\n            .find((x) => x.name === typeName);\n        return type ? this.extractFieldsFromType(type) : [];\n    }\n    /**\n     * Builds the fields part of the GraphQL query.\n     *\n     * @param fields List of fields to query.\n     * @param withId Boolean to add a default ID field.\n     * @returns QL document to build the query.\n     */\n    buildFields(fields, withId = true) {\n        const defaultField = withId ? ['id\\n'] : [];\n        return defaultField.concat(fields.map((x) => {\n            switch (x.kind) {\n                case 'SCALAR': {\n                    return x.name + '\\n';\n                }\n                case 'LIST': {\n                    if (x.type.endsWith(REFERENCE_DATA_END)) {\n                        return (`${x.name} {\n              ${this.buildFields(x.fields, false)}\n            }` + '\\n');\n                    }\n                    return (`${x.name} (\n            sortField: ${x.sort.field ? `\"${x.sort.field}\"` : null},\n            sortOrder: \"${x.sort.order}\",\n            first: ${get(x, 'first', null)},\n            filter: ${this.filterToString(x.filter)}\n          ) {\n            ${['canUpdate\\ncanDelete\\n'].concat(this.buildFields(x.fields))}\n          }` + '\\n');\n                }\n                case 'OBJECT': {\n                    return (`${x.name} {\n            ${this.buildFields(x.fields, !x.type.endsWith(REFERENCE_DATA_END))}\n          }` + '\\n');\n                }\n                default: {\n                    return '';\n                }\n            }\n        }));\n    }\n    /**\n     * Builds parsable GraphQL string from the filter definition.\n     *\n     * @param filter Filter definition\n     * @returns GraphQL parsable strinf for the filter.\n     */\n    filterToString(filter) {\n        if (filter.filters) {\n            return `{ logic: \"${filter.logic}\", filters: [${filter.filters.map((x) => this.filterToString(x))}]}`;\n        }\n        else {\n            return `{ field: \"${filter.field}\", operator: \"${filter.operator}\", value: \"${filter.value}\" }`;\n        }\n    }\n    /**\n     * Builds the fields part of the GraphQL meta query.\n     *\n     * @param fields List of fields to query.\n     * @returns QL document to build the query.\n     */\n    buildMetaFields(fields) {\n        if (!fields) {\n            return '';\n        }\n        return [''].concat(fields.map((x) => {\n            var _a;\n            const kind = x.kind || ((_a = x.type) === null || _a === void 0 ? void 0 : _a.kind);\n            switch (kind) {\n                case 'SCALAR': {\n                    return x.name + '\\n';\n                }\n                case 'LIST': {\n                    const subFields = get(x, 'fields', []) || get(x, 'type.fields', []);\n                    if (subFields.length > 0) {\n                        return (`${x.name} {\n              ${this.buildMetaFields(subFields)}\n            }` + '\\n');\n                    }\n                    else {\n                        return '';\n                    }\n                }\n                case 'OBJECT': {\n                    const subFields = get(x, 'fields', []) || get(x, 'type.fields', []);\n                    if (subFields.length > 0) {\n                        return (`${x.name} {\n              ${this.buildMetaFields(subFields)}\n            }` + '\\n');\n                    }\n                    else {\n                        return '';\n                    }\n                }\n                default: {\n                    return '';\n                }\n            }\n        }));\n    }\n    /**\n     * Builds a form / resource query from widget settings.\n     * TODO: we should pass directly the query definition, instead of the settings.\n     *\n     * @param settings Widget settings.\n     * @returns GraphQL query.\n     */\n    buildQuery(settings) {\n        var _a;\n        const builtQuery = settings.query;\n        if (((_a = builtQuery === null || builtQuery === void 0 ? void 0 : builtQuery.fields) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n            const fields = ['canUpdate\\ncanDelete\\n'].concat(this.buildFields(builtQuery.fields));\n            return this.graphqlQuery(builtQuery.name, fields);\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Builds a graphQL query from name and fields strings.\n     *\n     * @param name name of the query.\n     * @param fields fields to fetch.\n     * @returns GraphQL query.\n     */\n    graphqlQuery(name, fields) {\n        return gql `\n    query GetCustomQuery($first: Int, $skip: Int, $filter: JSON, $sortField: String, $sortOrder: String, $display: Boolean, $styles: JSON) {\n      ${name}(\n      first: $first,\n      skip: $skip,\n      sortField: $sortField,\n      sortOrder: $sortOrder,\n      filter: $filter,\n      display: $display\n      styles: $styles\n      ) {\n        edges {\n          node {\n            ${fields}\n          }\n          meta\n        }\n        totalCount\n      }\n    }\n  `;\n    }\n    /**\n     * Builds a GraphQL meta query of a form / resource from widget settings.\n     *\n     * @param query Widget query.\n     * @returns GraphQL meta query.\n     */\n    buildMetaQuery(query) {\n        if (query && query.fields.length > 0) {\n            const metaFields = this.buildMetaFields(query.fields);\n            const metaQuery = gql `\n        query GetCustomMetaQuery {\n          _${query.name}Meta {\n            ${metaFields}\n          }\n        }\n      `;\n            return this.apollo.query({\n                query: metaQuery,\n                variables: {},\n                fetchPolicy: 'cache-first',\n            });\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Get source query ( form / resource ) from query\n     *\n     * @param query custom query\n     * @returns apollo query to get source\n     */\n    getQuerySource(query) {\n        if (query) {\n            const sourceQuery = gql `\n      query GetSourceQuery {\n        _${query.name}Meta {\n          _source\n        }\n      }\n    `;\n            return this.apollo.query({\n                query: sourceQuery,\n                variables: {},\n                fetchPolicy: 'cache-first',\n            });\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Get metadata of form or resource\n     *\n     * @param id id of form or resource\n     * @returns metadata query\n     */\n    getQueryMetaData(id) {\n        return this.apollo.query({\n            query: GET_QUERY_META_DATA,\n            variables: {\n                id,\n            },\n            fetchPolicy: 'cache-first',\n        });\n    }\n    /**\n     * Returns the query name from a resource name.\n     *\n     * @param resourceName Resource name\n     * @returns Query name\n     */\n    getQueryNameFromResourceName(resourceName) {\n        var _a;\n        const nameTrimmed = resourceName\n            .replace(/_|-/g, '')\n            .replace(/\\s+(?=\\d)/g, '_')\n            .replace(/\\s/g, '')\n            .toLowerCase();\n        return (((_a = this.availableQueries\n            .getValue()\n            .find((x) => x.type.name.toLowerCase() === nameTrimmed + 'connection')) === null || _a === void 0 ? void 0 : _a.name) || '');\n    }\n    /**\n     * Finds the source of a query.\n     * Used in order to find related forms.\n     *\n     * @param queryName Query name\n     * @returns Apollo query.\n     */\n    sourceQuery(queryName) {\n        const queries = this.availableQueries.getValue().map((x) => x.name);\n        if (queries.includes(queryName)) {\n            const query = gql `\n        query GetCustomSourceQuery {\n          _${queryName}Meta {\n            _source\n          }\n        }\n      `;\n            return this.apollo.query({\n                query,\n                variables: {},\n            });\n        }\n        else {\n            return null;\n        }\n    }\n};\nQueryBuilderService.ctorParameters = () => [\n    { type: Apollo },\n    { type: FormBuilder }\n];\nQueryBuilderService = __decorate([\n    Injectable({\n        providedIn: 'root',\n    })\n], QueryBuilderService);\nexport { QueryBuilderService };\n"],"names":[],"sourceRoot":""}